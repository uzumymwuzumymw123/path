/* Pathfinder */ ! function (e) { if ("object" == typeof exports) module.exports = e(); else if ("function" == typeof define && define.amd) define(e); else { var o; "undefined" != typeof window ? o = window : "undefined" != typeof global ? o = global : "undefined" != typeof self && (o = self), o.PF = e() } }((function () { return function e(o, i, t) { function n(r, u) { if (!i[r]) { if (!o[r]) { var s = "function" == typeof require && require; if (!u && s) return s(r, !0); if (a) return a(r, !0); throw new Error("Cannot find module '" + r + "'") } var v = i[r] = { exports: {} }; o[r][0].call(v.exports, (function (e) { return n(o[r][1][e] || e) }), v, v.exports, e, o, i, t) } return i[r].exports } for (var a = "function" == typeof require && require, r = 0; r < t.length; r++) n(t[r]); return n }({ 1: [function (e, o, i) { o.exports = e("./lib/heap") }, { "./lib/heap": 2 }], 2: [function (e, o, i) { (function () { var e, i, t, n, a, r, u, s, v, h, l, d, g, O, w; t = Math.floor, h = Math.min, i = function (e, o) { return o > e ? -1 : e > o ? 1 : 0 }, v = function (e, o, n, a, r) { var u; if (null == n && (n = 0), null == r && (r = i), 0 > n) throw new Error("lo must be non-negative"); for (null == a && (a = e.length); a > n;) r(o, e[u = t((n + a) / 2)]) < 0 ? a = u : n = u + 1; return [].splice.apply(e, [n, n - n].concat(o)), o }, r = function (e, o, t) { return null == t && (t = i), e.push(o), O(e, 0, e.length - 1, t) }, a = function (e, o) { var t, n; return null == o && (o = i), t = e.pop(), e.length ? (n = e[0], e[0] = t, w(e, 0, o)) : n = t, n }, s = function (e, o, t) { var n; return null == t && (t = i), n = e[0], e[0] = o, w(e, 0, t), n }, u = function (e, o, t) { var n; return null == t && (t = i), e.length && t(e[0], o) < 0 && (o = (n = [e[0], o])[0], e[0] = n[1], w(e, 0, t)), o }, n = function (e, o) { var n, a, r, u, s, v; for (null == o && (o = i), s = [], a = 0, r = (u = function () { v = []; for (var o = 0, i = t(e.length / 2); i >= 0 ? i > o : o > i; i >= 0 ? o++ : o--) v.push(o); return v }.apply(this).reverse()).length; r > a; a++) n = u[a], s.push(w(e, n, o)); return s }, g = function (e, o, t) { var n; return null == t && (t = i), -1 !== (n = e.indexOf(o)) ? (O(e, 0, n, t), w(e, n, t)) : void 0 }, l = function (e, o, t) { var a, r, s, v, h; if (null == t && (t = i), !(r = e.slice(0, o)).length) return r; for (n(r, t), s = 0, v = (h = e.slice(o)).length; v > s; s++) a = h[s], u(r, a, t); return r.sort(t).reverse() }, d = function (e, o, t) { var r, u, s, l, d, g, O, w, c; if (null == t && (t = i), 10 * o <= e.length) { if (!(s = e.slice(0, o).sort(t)).length) return s; for (u = s[s.length - 1], l = 0, g = (O = e.slice(o)).length; g > l; l++) t(r = O[l], u) < 0 && (v(s, r, 0, null, t), s.pop(), u = s[s.length - 1]); return s } for (n(e, t), c = [], d = 0, w = h(o, e.length); w >= 0 ? w > d : d > w; w >= 0 ? ++d : --d) c.push(a(e, t)); return c }, O = function (e, o, t, n) { var a, r, u; for (null == n && (n = i), a = e[t]; t > o && n(a, r = e[u = t - 1 >> 1]) < 0;) e[t] = r, t = u; return e[t] = a }, w = function (e, o, t) { var n, a, r, u, s; for (null == t && (t = i), a = e.length, s = o, r = e[o], n = 2 * o + 1; a > n;) a > (u = n + 1) && !(t(e[n], e[u]) < 0) && (n = u), e[o] = e[n], n = 2 * (o = n) + 1; return e[o] = r, O(e, s, o, t) }, e = function () { function e(e) { this.cmp = null != e ? e : i, this.nodes = [] } return e.push = r, e.pop = a, e.replace = s, e.pushpop = u, e.heapify = n, e.updateItem = g, e.nlargest = l, e.nsmallest = d, e.prototype.push = function (e) { return r(this.nodes, e, this.cmp) }, e.prototype.pop = function () { return a(this.nodes, this.cmp) }, e.prototype.peek = function () { return this.nodes[0] }, e.prototype.contains = function (e) { return -1 !== this.nodes.indexOf(e) }, e.prototype.replace = function (e) { return s(this.nodes, e, this.cmp) }, e.prototype.pushpop = function (e) { return u(this.nodes, e, this.cmp) }, e.prototype.heapify = function () { return n(this.nodes, this.cmp) }, e.prototype.updateItem = function (e) { return g(this.nodes, e, this.cmp) }, e.prototype.clear = function () { return this.nodes = [] }, e.prototype.empty = function () { return 0 === this.nodes.length }, e.prototype.size = function () { return this.nodes.length }, e.prototype.clone = function () { var o; return (o = new e).nodes = this.nodes.slice(0), o }, e.prototype.toArray = function () { return this.nodes.slice(0) }, e.prototype.insert = e.prototype.push, e.prototype.top = e.prototype.peek, e.prototype.front = e.prototype.peek, e.prototype.has = e.prototype.contains, e.prototype.copy = e.prototype.clone, e }(), (null != o ? o.exports : void 0) ? o.exports = e : window.Heap = e }).call(this) }, {}], 3: [function (e, o, i) { o.exports = { Always: 1, Never: 2, IfAtMostOneObstacle: 3, OnlyWhenNoObstacles: 4 } }, {}], 4: [function (e, o, i) { function t(e, o, i) { var t; "object" != typeof e ? t = e : (o = e.length, t = e[0].length, i = e), this.width = t, this.height = o, this.nodes = this._buildNodes(t, o, i) } var n = e("./Node"), a = e("./DiagonalMovement"); t.prototype._buildNodes = function (e, o, i) { var t, a, r = new Array(o); for (t = 0; o > t; ++t) for (r[t] = new Array(e), a = 0; e > a; ++a) r[t][a] = new n(a, t); if (void 0 === i) return r; if (i.length !== o || i[0].length !== e) throw new Error("Matrix size does not fit"); for (t = 0; o > t; ++t) for (a = 0; e > a; ++a) i[t][a] && (r[t][a].walkable = !1); return r }, t.prototype.getNodeAt = function (e, o) { return this.nodes[o][e] }, t.prototype.isWalkableAt = function (e, o) { return this.isInside(e, o) && this.nodes[o][e].walkable }, t.prototype.isInside = function (e, o) { return e >= 0 && e < this.width && o >= 0 && o < this.height }, t.prototype.setWalkableAt = function (e, o, i) { o >= 0 && e >= 0 && o <unsafeWindow.wrld.nw&& e < unsafeWindow.wrld.nh && (this.nodes[o][e].walkable = i) }, t.prototype.getNeighbors = function (e, o) { var i = e.x, t = e.y, n = [], r = !1, u = !1, s = !1, v = !1, h = !1, l = !1, d = !1, g = !1, O = this.nodes; if (this.isWalkableAt(i, t - 1) && (n.push(O[t - 1][i]), r = !0), this.isWalkableAt(i + 1, t) && (n.push(O[t][i + 1]), s = !0), this.isWalkableAt(i, t + 1) && (n.push(O[t + 1][i]), h = !0), this.isWalkableAt(i - 1, t) && (n.push(O[t][i - 1]), d = !0), o === a.Never) return n; if (o === a.OnlyWhenNoObstacles) u = d && r, v = r && s, l = s && h, g = h && d; else if (o === a.IfAtMostOneObstacle) u = d || r, v = r || s, l = s || h, g = h || d; else { if (o !== a.Always) throw new Error("Incorrect value of diagonalMovement"); u = !0, v = !0, l = !0, g = !0 } return u && this.isWalkableAt(i - 1, t - 1) && n.push(O[t - 1][i - 1]), v && this.isWalkableAt(i + 1, t - 1) && n.push(O[t - 1][i + 1]), l && this.isWalkableAt(i + 1, t + 1) && n.push(O[t + 1][i + 1]), g && this.isWalkableAt(i - 1, t + 1) && n.push(O[t + 1][i - 1]), n }, t.prototype.clone = function () { var e, o, i = this.width, a = this.height, r = this.nodes, u = new t(i, a), s = new Array(a); for (e = 0; a > e; ++e) for (s[e] = new Array(i), o = 0; i > o; ++o) s[e][o] = new n(o, e, r[e][o].walkable); return u.nodes = s, u }, o.exports = t }, { "./DiagonalMovement": 3, "./Node": 6 }], 5: [function (e, o, i) { o.exports = { manhattan: function (e, o) { return e + o }, euclidean: function (e, o) { return Math.sqrt(e * e + o * o) }, octile: function (e, o) { var i = Math.SQRT2 - 1; return o > e ? i * e + o : i * o + e }, chebyshev: function (e, o) { return Math.max(e, o) } } }, {}], 6: [function (e, o, i) { o.exports = function (e, o, i) { this.x = e, this.y = o, this.walkable = void 0 === i || i } }, {}], 7: [function (e, o, i) { function t(e) { for (var o = [[e.x, e.y]]; e.parent;) e = e.parent, o.push([e.x, e.y]); return o.reverse() } function n(e, o, i, t) { var n, a, r, u, s, v, h = Math.abs, l = []; for (n = i > e ? 1 : -1, a = t > o ? 1 : -1, s = (r = h(i - e)) - (u = h(t - o)); l.push([e, o]), e !== i || o !== t;)(v = 2 * s) > -u && (s -= u, e += n), r > v && (s += r, o += a); return l } i.backtrace = t, i.biBacktrace = function (e, o) { var i = t(e), n = t(o); return i.concat(n.reverse()) }, i.pathLength = function (e) { var o, i, t, n, a, r = 0; for (o = 1; o < e.length; ++o) i = e[o - 1], t = e[o], n = i[0] - t[0], a = i[1] - t[1], r += Math.sqrt(n * n + a * a); return r }, i.interpolate = n, i.expandPath = function (e) { var o, i, t, a, r, u, s = [], v = e.length; if (2 > v) return s; for (r = 0; v - 1 > r; ++r) for (o = e[r], i = e[r + 1], a = (t = n(o[0], o[1], i[0], i[1])).length, u = 0; a - 1 > u; ++u) s.push(t[u]); return s.push(e[v - 1]), s }, i.smoothenPath = function (e, o) { var i, t, a, r, u, s, v, h, l, d = o.length, g = o[0][0], O = o[0][1], w = o[d - 1][0], c = o[d - 1][1]; for (a = [[i = g, t = O]], r = 2; d > r; ++r) { for (v = n(i, t, (s = o[r])[0], s[1]), l = !1, u = 1; u < v.length; ++u) if (h = v[u], !e.isWalkableAt(h[0], h[1])) { l = !0; break } l && (lastValidCoord = o[r - 1], a.push(lastValidCoord), i = lastValidCoord[0], t = lastValidCoord[1]) } return a.push([w, c]), a }, i.compressPath = function (e) { if (e.length < 3) return e; var o, i, t, n, a, r, u = [], s = e[0][0], v = e[0][1], h = e[1][0], l = e[1][1], d = h - s, g = l - v; for (d /= a = Math.sqrt(d * d + g * g), g /= a, u.push([s, v]), r = 2; r < e.length; r++) o = h, i = l, t = d, n = g, d = (h = e[r][0]) - o, g = (l = e[r][1]) - i, g /= a = Math.sqrt(d * d + g * g), (d /= a) === t && g === n || u.push([o, i]); return u.push([h, l]), u } }, {}], 8: [function (e, o, i) { o.exports = { Heap: e("heap"), Node: e("./core/Node"), Grid: e("./core/Grid"), Util: e("./core/Util"), DiagonalMovement: e("./core/DiagonalMovement"), Heuristic: e("./core/Heuristic"), AStarFinder: e("./finders/AStarFinder"), BestFirstFinder: e("./finders/BestFirstFinder"), BreadthFirstFinder: e("./finders/BreadthFirstFinder"), DijkstraFinder: e("./finders/DijkstraFinder"), BiAStarFinder: e("./finders/BiAStarFinder"), BiBestFirstFinder: e("./finders/BiBestFirstFinder"), BiBreadthFirstFinder: e("./finders/BiBreadthFirstFinder"), BiDijkstraFinder: e("./finders/BiDijkstraFinder"), IDAStarFinder: e("./finders/IDAStarFinder"), JumpPointFinder: e("./finders/JumpPointFinder") } }, { "./core/DiagonalMovement": 3, "./core/Grid": 4, "./core/Heuristic": 5, "./core/Node": 6, "./core/Util": 7, "./finders/AStarFinder": 9, "./finders/BestFirstFinder": 10, "./finders/BiAStarFinder": 11, "./finders/BiBestFirstFinder": 12, "./finders/BiBreadthFirstFinder": 13, "./finders/BiDijkstraFinder": 14, "./finders/BreadthFirstFinder": 15, "./finders/DijkstraFinder": 16, "./finders/IDAStarFinder": 17, "./finders/JumpPointFinder": 22, heap: 1 }], 9: [function (e, o, i) { function t(e) { e = e || {}, this.allowDiagonal = e.allowDiagonal, this.dontCrossCorners = e.dontCrossCorners, this.heuristic = e.heuristic || r.manhattan, this.weight = e.weight || 1, this.diagonalMovement = e.diagonalMovement, this.diagonalMovement || (this.allowDiagonal ? this.dontCrossCorners ? this.diagonalMovement = u.OnlyWhenNoObstacles : this.diagonalMovement = u.IfAtMostOneObstacle : this.diagonalMovement = u.Never), this.diagonalMovement === u.Never ? this.heuristic = e.heuristic || r.manhattan : this.heuristic = e.heuristic || r.octile } var n = e("heap"), a = e("../core/Util"), r = e("../core/Heuristic"), u = e("../core/DiagonalMovement"); t.prototype.findPath = function (e, o, i, t, r) { var u, s, v, h, l, d, g, O, w = new n((function (e, o) { return e.f - o.f })), c = r.getNodeAt(e, o), V = r.getNodeAt(i, t), b = this.heuristic, m = this.diagonalMovement, p = this.weight, f = Math.abs, U = Math.SQRT2; for (c.g = 0, c.f = 0, w.push(c), c.opened = !0; !w.empty();) { if ((u = w.pop()).closed = !0, u === V) return a.backtrace(V); for (h = 0, l = (s = r.getNeighbors(u, m)).length; l > h; ++h)(v = s[h]).closed || (d = v.x, g = v.y, O = u.g + (d - u.x == 0 || g - u.y == 0 ? 1 : U), (!v.opened || O < v.g) && (v.g = O, v.h = v.h || p * b(f(d - i), f(g - t)), v.f = v.g + v.h, v.parent = u, v.opened ? w.updateItem(v) : (w.push(v), v.opened = !0))) } return [] }, o.exports = t }, { "../core/DiagonalMovement": 3, "../core/Heuristic": 5, "../core/Util": 7, heap: 1 }], 10: [function (e, o, i) { function t(e) { n.call(this, e); var o = this.heuristic; this.heuristic = function (e, i) { return 1e6 * o(e, i) } } var n = e("./AStarFinder"); t.prototype = new n, t.prototype.constructor = t, o.exports = t }, { "./AStarFinder": 9 }], 11: [function (e, o, i) { function t(e) { e = e || {}, this.allowDiagonal = e.allowDiagonal, this.dontCrossCorners = e.dontCrossCorners, this.diagonalMovement = e.diagonalMovement, this.heuristic = e.heuristic || r.manhattan, this.weight = e.weight || 1, this.diagonalMovement || (this.allowDiagonal ? this.dontCrossCorners ? this.diagonalMovement = u.OnlyWhenNoObstacles : this.diagonalMovement = u.IfAtMostOneObstacle : this.diagonalMovement = u.Never), this.diagonalMovement === u.Never ? this.heuristic = e.heuristic || r.manhattan : this.heuristic = e.heuristic || r.octile } var n = e("heap"), a = e("../core/Util"), r = e("../core/Heuristic"), u = e("../core/DiagonalMovement"); t.prototype.findPath = function (e, o, i, t, r) { var u, s, v, h, l, d, g, O, w = function (e, o) { return e.f - o.f }, c = new n(w), V = new n(w), b = r.getNodeAt(e, o), m = r.getNodeAt(i, t), p = this.heuristic, f = this.diagonalMovement, U = this.weight, W = Math.abs, _ = Math.SQRT2; for (b.g = 0, b.f = 0, c.push(b), b.opened = 1, m.g = 0, m.f = 0, V.push(m), m.opened = 2; !c.empty() && !V.empty();) { for ((u = c.pop()).closed = !0, h = 0, l = (s = r.getNeighbors(u, f)).length; l > h; ++h) if (!(v = s[h]).closed) { if (2 === v.opened) return a.biBacktrace(u, v); d = v.x, g = v.y, O = u.g + (d - u.x == 0 || g - u.y == 0 ? 1 : _), (!v.opened || O < v.g) && (v.g = O, v.h = v.h || U * p(W(d - i), W(g - t)), v.f = v.g + v.h, v.parent = u, v.opened ? c.updateItem(v) : (c.push(v), v.opened = 1)) } for ((u = V.pop()).closed = !0, h = 0, l = (s = r.getNeighbors(u, f)).length; l > h; ++h) if (!(v = s[h]).closed) { if (1 === v.opened) return a.biBacktrace(v, u); d = v.x, g = v.y, O = u.g + (d - u.x == 0 || g - u.y == 0 ? 1 : _), (!v.opened || O < v.g) && (v.g = O, v.h = v.h || U * p(W(d - e), W(g - o)), v.f = v.g + v.h, v.parent = u, v.opened ? V.updateItem(v) : (V.push(v), v.opened = 2)) } } return [] }, o.exports = t }, { "../core/DiagonalMovement": 3, "../core/Heuristic": 5, "../core/Util": 7, heap: 1 }], 12: [function (e, o, i) { function t(e) { n.call(this, e); var o = this.heuristic; this.heuristic = function (e, i) { return 1e6 * o(e, i) } } var n = e("./BiAStarFinder"); t.prototype = new n, t.prototype.constructor = t, o.exports = t }, { "./BiAStarFinder": 11 }], 13: [function (e, o, i) { function t(e) { e = e || {}, this.allowDiagonal = e.allowDiagonal, this.dontCrossCorners = e.dontCrossCorners, this.diagonalMovement = e.diagonalMovement, this.diagonalMovement || (this.allowDiagonal ? this.dontCrossCorners ? this.diagonalMovement = a.OnlyWhenNoObstacles : this.diagonalMovement = a.IfAtMostOneObstacle : this.diagonalMovement = a.Never) } var n = e("../core/Util"), a = e("../core/DiagonalMovement"); t.prototype.findPath = function (e, o, i, t, a) { var r, u, s, v, h, l = a.getNodeAt(e, o), d = a.getNodeAt(i, t), g = [], O = [], w = this.diagonalMovement; for (g.push(l), l.opened = !0, l.by = 0, O.push(d), d.opened = !0, d.by = 1; g.length && O.length;) { for ((s = g.shift()).closed = !0, v = 0, h = (r = a.getNeighbors(s, w)).length; h > v; ++v) if (!(u = r[v]).closed) if (u.opened) { if (1 === u.by) return n.biBacktrace(s, u) } else g.push(u), u.parent = s, u.opened = !0, u.by = 0; for ((s = O.shift()).closed = !0, v = 0, h = (r = a.getNeighbors(s, w)).length; h > v; ++v) if (!(u = r[v]).closed) if (u.opened) { if (0 === u.by) return n.biBacktrace(u, s) } else O.push(u), u.parent = s, u.opened = !0, u.by = 1 } return [] }, o.exports = t }, { "../core/DiagonalMovement": 3, "../core/Util": 7 }], 14: [function (e, o, i) { function t(e) { n.call(this, e), this.heuristic = function (e, o) { return 0 } } var n = e("./BiAStarFinder"); t.prototype = new n, t.prototype.constructor = t, o.exports = t }, { "./BiAStarFinder": 11 }], 15: [function (e, o, i) { function t(e) { e = e || {}, this.allowDiagonal = e.allowDiagonal, this.dontCrossCorners = e.dontCrossCorners, this.diagonalMovement = e.diagonalMovement, this.diagonalMovement || (this.allowDiagonal ? this.dontCrossCorners ? this.diagonalMovement = a.OnlyWhenNoObstacles : this.diagonalMovement = a.IfAtMostOneObstacle : this.diagonalMovement = a.Never) } var n = e("../core/Util"), a = e("../core/DiagonalMovement"); t.prototype.findPath = function (e, o, i, t, a) { var r, u, s, v, h, l = [], d = this.diagonalMovement, g = a.getNodeAt(e, o), O = a.getNodeAt(i, t); for (l.push(g), g.opened = !0; l.length;) { if ((s = l.shift()).closed = !0, s === O) return n.backtrace(O); for (v = 0, h = (r = a.getNeighbors(s, d)).length; h > v; ++v)(u = r[v]).closed || u.opened || (l.push(u), u.opened = !0, u.parent = s) } return [] }, o.exports = t }, { "../core/DiagonalMovement": 3, "../core/Util": 7 }], 16: [function (e, o, i) { function t(e) { n.call(this, e), this.heuristic = function (e, o) { return 0 } } var n = e("./AStarFinder"); t.prototype = new n, t.prototype.constructor = t, o.exports = t }, { "./AStarFinder": 9 }], 17: [function (e, o, i) { function t(e) { e = e || {}, this.allowDiagonal = e.allowDiagonal, this.dontCrossCorners = e.dontCrossCorners, this.diagonalMovement = e.diagonalMovement, this.heuristic = e.heuristic || n.manhattan, this.weight = e.weight || 1, this.trackRecursion = e.trackRecursion || !1, this.timeLimit = e.timeLimit || 1 / 0, this.diagonalMovement || (this.allowDiagonal ? this.dontCrossCorners ? this.diagonalMovement = r.OnlyWhenNoObstacles : this.diagonalMovement = r.IfAtMostOneObstacle : this.diagonalMovement = r.Never), this.diagonalMovement === r.Never ? this.heuristic = e.heuristic || n.manhattan : this.heuristic = e.heuristic || n.octile } var n = (e("../core/Util"), e("../core/Heuristic")), a = e("../core/Node"), r = e("../core/DiagonalMovement"); t.prototype.findPath = function (e, o, i, t, n) { var r, u, s, v = (new Date).getTime(), h = function (e, o) { return this.heuristic(Math.abs(o.x - e.x), Math.abs(o.y - e.y)) }.bind(this), l = function (e, o) { return e.x === o.x || e.y === o.y ? 1 : Math.SQRT2 }, d = function (e, o, i, t, r) { if (this.timeLimit > 0 && (new Date).getTime() - v > 1e3 * this.timeLimit) return 1 / 0; var u = o + h(e, O) * this.weight; if (u > i) return u; if (e == O) return t[r] = [e.x, e.y], e; var s, g, w, c, V = n.getNeighbors(e, this.diagonalMovement); for (w = 0, s = 1 / 0; c = V[w]; ++w) { if (this.trackRecursion && (c.retainCount = c.retainCount + 1 || 1, !0 !== c.tested && (c.tested = !0)), (g = d(c, o + l(e, c), i, t, r + 1)) instanceof a) return t[r] = [e.x, e.y], g; this.trackRecursion && 0 == --c.retainCount && (c.tested = !1), s > g && (s = g) } return s }.bind(this), g = n.getNodeAt(e, o), O = n.getNodeAt(i, t), w = h(g, O); for (r = 0; ; ++r) { if (1 / 0 === (s = d(g, 0, w, u = [], 0))) return []; if (s instanceof a) return u; w = s } return [] }, o.exports = t }, { "../core/DiagonalMovement": 3, "../core/Heuristic": 5, "../core/Node": 6, "../core/Util": 7 }], 18: [function (e, o, i) { function t(e) { n.call(this, e) } var n = e("./JumpPointFinderBase"), a = e("../core/DiagonalMovement"); t.prototype = new n, t.prototype.constructor = t, t.prototype._jump = function (e, o, i, t) { var n = this.grid, a = e - i, r = o - t; if (!n.isWalkableAt(e, o)) return null; if (!0 === this.trackJumpRecursion && (n.getNodeAt(e, o).tested = !0), n.getNodeAt(e, o) === this.endNode) return [e, o]; if (0 !== a && 0 !== r) { if (n.isWalkableAt(e - a, o + r) && !n.isWalkableAt(e - a, o) || n.isWalkableAt(e + a, o - r) && !n.isWalkableAt(e, o - r)) return [e, o]; if (this._jump(e + a, o, e, o) || this._jump(e, o + r, e, o)) return [e, o] } else if (0 !== a) { if (n.isWalkableAt(e + a, o + 1) && !n.isWalkableAt(e, o + 1) || n.isWalkableAt(e + a, o - 1) && !n.isWalkableAt(e, o - 1)) return [e, o] } else if (n.isWalkableAt(e + 1, o + r) && !n.isWalkableAt(e + 1, o) || n.isWalkableAt(e - 1, o + r) && !n.isWalkableAt(e - 1, o)) return [e, o]; return this._jump(e + a, o + r, e, o) }, t.prototype._findNeighbors = function (e) { var o, i, t, n, r, u, s, v, h = e.parent, l = e.x, d = e.y, g = this.grid, O = []; if (h) o = h.x, i = h.y, t = (l - o) / Math.max(Math.abs(l - o), 1), n = (d - i) / Math.max(Math.abs(d - i), 1), 0 !== t && 0 !== n ? (g.isWalkableAt(l, d + n) && O.push([l, d + n]), g.isWalkableAt(l + t, d) && O.push([l + t, d]), g.isWalkableAt(l + t, d + n) && O.push([l + t, d + n]), g.isWalkableAt(l - t, d) || O.push([l - t, d + n]), g.isWalkableAt(l, d - n) || O.push([l + t, d - n])) : 0 === t ? (g.isWalkableAt(l, d + n) && O.push([l, d + n]), g.isWalkableAt(l + 1, d) || O.push([l + 1, d + n]), g.isWalkableAt(l - 1, d) || O.push([l - 1, d + n])) : (g.isWalkableAt(l + t, d) && O.push([l + t, d]), g.isWalkableAt(l, d + 1) || O.push([l + t, d + 1]), g.isWalkableAt(l, d - 1) || O.push([l + t, d - 1])); else for (s = 0, v = (r = g.getNeighbors(e, a.Always)).length; v > s; ++s) u = r[s], O.push([u.x, u.y]); return O }, o.exports = t }, { "../core/DiagonalMovement": 3, "./JumpPointFinderBase": 23 }], 19: [function (e, o, i) { function t(e) { n.call(this, e) } var n = e("./JumpPointFinderBase"), a = e("../core/DiagonalMovement"); t.prototype = new n, t.prototype.constructor = t, t.prototype._jump = function (e, o, i, t) { var n = this.grid, a = e - i, r = o - t; if (!n.isWalkableAt(e, o)) return null; if (!0 === this.trackJumpRecursion && (n.getNodeAt(e, o).tested = !0), n.getNodeAt(e, o) === this.endNode) return [e, o]; if (0 !== a && 0 !== r) { if (n.isWalkableAt(e - a, o + r) && !n.isWalkableAt(e - a, o) || n.isWalkableAt(e + a, o - r) && !n.isWalkableAt(e, o - r)) return [e, o]; if (this._jump(e + a, o, e, o) || this._jump(e, o + r, e, o)) return [e, o] } else if (0 !== a) { if (n.isWalkableAt(e + a, o + 1) && !n.isWalkableAt(e, o + 1) || n.isWalkableAt(e + a, o - 1) && !n.isWalkableAt(e, o - 1)) return [e, o] } else if (n.isWalkableAt(e + 1, o + r) && !n.isWalkableAt(e + 1, o) || n.isWalkableAt(e - 1, o + r) && !n.isWalkableAt(e - 1, o)) return [e, o]; return n.isWalkableAt(e + a, o) || n.isWalkableAt(e, o + r) ? this._jump(e + a, o + r, e, o) : null }, t.prototype._findNeighbors = function (e) { var o, i, t, n, r, u, s, v, h = e.parent, l = e.x, d = e.y, g = this.grid, O = []; if (h) o = h.x, i = h.y, t = (l - o) / Math.max(Math.abs(l - o), 1), n = (d - i) / Math.max(Math.abs(d - i), 1), 0 !== t && 0 !== n ? (g.isWalkableAt(l, d + n) && O.push([l, d + n]), g.isWalkableAt(l + t, d) && O.push([l + t, d]), (g.isWalkableAt(l, d + n) || g.isWalkableAt(l + t, d)) && O.push([l + t, d + n]), !g.isWalkableAt(l - t, d) && g.isWalkableAt(l, d + n) && O.push([l - t, d + n]), !g.isWalkableAt(l, d - n) && g.isWalkableAt(l + t, d) && O.push([l + t, d - n])) : 0 === t ? g.isWalkableAt(l, d + n) && (O.push([l, d + n]), g.isWalkableAt(l + 1, d) || O.push([l + 1, d + n]), g.isWalkableAt(l - 1, d) || O.push([l - 1, d + n])) : g.isWalkableAt(l + t, d) && (O.push([l + t, d]), g.isWalkableAt(l, d + 1) || O.push([l + t, d + 1]), g.isWalkableAt(l, d - 1) || O.push([l + t, d - 1])); else for (s = 0, v = (r = g.getNeighbors(e, a.IfAtMostOneObstacle)).length; v > s; ++s) u = r[s], O.push([u.x, u.y]); return O }, o.exports = t }, { "../core/DiagonalMovement": 3, "./JumpPointFinderBase": 23 }], 20: [function (e, o, i) { function t(e) { n.call(this, e) } var n = e("./JumpPointFinderBase"), a = e("../core/DiagonalMovement"); t.prototype = new n, t.prototype.constructor = t, t.prototype._jump = function (e, o, i, t) { var n = this.grid, a = e - i, r = o - t; if (!n.isWalkableAt(e, o)) return null; if (!0 === this.trackJumpRecursion && (n.getNodeAt(e, o).tested = !0), n.getNodeAt(e, o) === this.endNode) return [e, o]; if (0 !== a && 0 !== r) { if (this._jump(e + a, o, e, o) || this._jump(e, o + r, e, o)) return [e, o] } else if (0 !== a) { if (n.isWalkableAt(e, o - 1) && !n.isWalkableAt(e - a, o - 1) || n.isWalkableAt(e, o + 1) && !n.isWalkableAt(e - a, o + 1)) return [e, o] } else if (0 !== r && (n.isWalkableAt(e - 1, o) && !n.isWalkableAt(e - 1, o - r) || n.isWalkableAt(e + 1, o) && !n.isWalkableAt(e + 1, o - r))) return [e, o]; return n.isWalkableAt(e + a, o) && n.isWalkableAt(e, o + r) ? this._jump(e + a, o + r, e, o) : null }, t.prototype._findNeighbors = function (e) { var o, i, t, n, r, u, s, v, h = e.parent, l = e.x, d = e.y, g = this.grid, O = []; if (h) if (o = h.x, i = h.y, t = (l - o) / Math.max(Math.abs(l - o), 1), n = (d - i) / Math.max(Math.abs(d - i), 1), 0 !== t && 0 !== n) g.isWalkableAt(l, d + n) && O.push([l, d + n]), g.isWalkableAt(l + t, d) && O.push([l + t, d]), g.isWalkableAt(l, d + n) && g.isWalkableAt(l + t, d) && O.push([l + t, d + n]); else { var w; if (0 !== t) { w = g.isWalkableAt(l + t, d); var c = g.isWalkableAt(l, d + 1), V = g.isWalkableAt(l, d - 1); w && (O.push([l + t, d]), c && O.push([l + t, d + 1]), V && O.push([l + t, d - 1])), c && O.push([l, d + 1]), V && O.push([l, d - 1]) } else if (0 !== n) { w = g.isWalkableAt(l, d + n); var b = g.isWalkableAt(l + 1, d), m = g.isWalkableAt(l - 1, d); w && (O.push([l, d + n]), b && O.push([l + 1, d + n]), m && O.push([l - 1, d + n])), b && O.push([l + 1, d]), m && O.push([l - 1, d]) } } else for (s = 0, v = (r = g.getNeighbors(e, a.OnlyWhenNoObstacles)).length; v > s; ++s) u = r[s], O.push([u.x, u.y]); return O }, o.exports = t }, { "../core/DiagonalMovement": 3, "./JumpPointFinderBase": 23 }], 21: [function (e, o, i) { function t(e) { n.call(this, e) } var n = e("./JumpPointFinderBase"), a = e("../core/DiagonalMovement"); t.prototype = new n, t.prototype.constructor = t, t.prototype._jump = function (e, o, i, t) { var n = this.grid, a = e - i, r = o - t; if (!n.isWalkableAt(e, o)) return null; if (!0 === this.trackJumpRecursion && (n.getNodeAt(e, o).tested = !0), n.getNodeAt(e, o) === this.endNode) return [e, o]; if (0 !== a) { if (n.isWalkableAt(e, o - 1) && !n.isWalkableAt(e - a, o - 1) || n.isWalkableAt(e, o + 1) && !n.isWalkableAt(e - a, o + 1)) return [e, o] } else { if (0 === r) throw new Error("Only horizontal and vertical movements are allowed"); if (n.isWalkableAt(e - 1, o) && !n.isWalkableAt(e - 1, o - r) || n.isWalkableAt(e + 1, o) && !n.isWalkableAt(e + 1, o - r)) return [e, o]; if (this._jump(e + 1, o, e, o) || this._jump(e - 1, o, e, o)) return [e, o] } return this._jump(e + a, o + r, e, o) }, t.prototype._findNeighbors = function (e) { var o, i, t, n, r, u, s, v, h = e.parent, l = e.x, d = e.y, g = this.grid, O = []; if (h) o = h.x, i = h.y, t = (l - o) / Math.max(Math.abs(l - o), 1), n = (d - i) / Math.max(Math.abs(d - i), 1), 0 !== t ? (g.isWalkableAt(l, d - 1) && O.push([l, d - 1]), g.isWalkableAt(l, d + 1) && O.push([l, d + 1]), g.isWalkableAt(l + t, d) && O.push([l + t, d])) : 0 !== n && (g.isWalkableAt(l - 1, d) && O.push([l - 1, d]), g.isWalkableAt(l + 1, d) && O.push([l + 1, d]), g.isWalkableAt(l, d + n) && O.push([l, d + n])); else for (s = 0, v = (r = g.getNeighbors(e, a.Never)).length; v > s; ++s) u = r[s], O.push([u.x, u.y]); return O }, o.exports = t }, { "../core/DiagonalMovement": 3, "./JumpPointFinderBase": 23 }], 22: [function (e, o, i) { var t = e("../core/DiagonalMovement"), n = e("./JPFNeverMoveDiagonally"), a = e("./JPFAlwaysMoveDiagonally"), r = e("./JPFMoveDiagonallyIfNoObstacles"), u = e("./JPFMoveDiagonallyIfAtMostOneObstacle"); o.exports = function (e) { return (e = e || {}).diagonalMovement === t.Never ? new n(e) : e.diagonalMovement === t.Always ? new a(e) : e.diagonalMovement === t.OnlyWhenNoObstacles ? new r(e) : new u(e) } }, { "../core/DiagonalMovement": 3, "./JPFAlwaysMoveDiagonally": 18, "./JPFMoveDiagonallyIfAtMostOneObstacle": 19, "./JPFMoveDiagonallyIfNoObstacles": 20, "./JPFNeverMoveDiagonally": 21 }], 23: [function (e, o, i) { function t(e) { e = e || {}, this.heuristic = e.heuristic || r.manhattan, this.trackJumpRecursion = e.trackJumpRecursion || !1 } var n = e("heap"), a = e("../core/Util"), r = e("../core/Heuristic"); e("../core/DiagonalMovement"), t.prototype.findPath = function (e, o, i, t, r) { var u, s = this.openList = new n((function (e, o) { return e.f - o.f })), v = this.startNode = r.getNodeAt(e, o), h = this.endNode = r.getNodeAt(i, t); for (this.grid = r, v.g = 0, v.f = 0, s.push(v), v.opened = !0; !s.empty();) { if ((u = s.pop()).closed = !0, u === h) return a.expandPath(a.backtrace(h)); this._identifySuccessors(u) } return [] }, t.prototype._identifySuccessors = function (e) { var o, i, t, n, a, u, s, v, h, l, d = this.grid, g = this.heuristic, O = this.openList, w = this.endNode.x, c = this.endNode.y, V = e.x, b = e.y, m = Math.abs; for (Math.max, n = 0, a = (o = this._findNeighbors(e)).length; a > n; ++n) if (i = o[n], t = this._jump(i[0], i[1], V, b)) { if (u = t[0], s = t[1], (l = d.getNodeAt(u, s)).closed) continue; v = r.octile(m(u - V), m(s - b)), h = e.g + v, (!l.opened || h < l.g) && (l.g = h, l.h = l.h || g(m(u - w), m(s - c)), l.f = l.g + l.h, l.parent = e, l.opened ? O.updateItem(l) : (O.push(l), l.opened = !0)) } }, o.exports = t }, { "../core/DiagonalMovement": 3, "../core/Heuristic": 5, "../core/Util": 7, heap: 1 }] }, {}, [8])(8) }));
